### Синтаксис

В других разделах для объяснения ключевых концепций, которые никак не связаны с синтаксисом, будет использован синтаксис языка `Rust`, или что-то очень похожее на него.

Здесь же собраны ключевые проблемы синтаксиса языка `Rust` и способы их исправить

### Отсутствие `;`

В `Rust` символ `;` не только необходим для завершения любого выражения, его отсутствие имеет специальный смысл - возвращение величины из скоупа `{}`.

Это неэргономично потому что бесполезно - часто выражения можно легко разделять по строчкам. Как правило после `;` тут же следует перенос строки.

Так же для разделения используются ключевые слова. После того места, где заканчивается одна строчка с текстом, может следовать `let` или окончание скоупа `}`.

Часто выражения можно разделять друг от друга даже с помощью пробела.
- Если функция вызвана, её вызов заканчивается `()`. Следующее после этого выражение очевидно не относится к результату этой функции, если оно не начинается с `.`.
- Если выражение состоит из присвоения поля некоторой структуры в переменную, дальнейшее выражение тоже легко отделяется от предыдущего отсутствием `.`.

Таким образом, выражение заканчивается на `()` при вызове функции или пробела/переноса строки при отсутствии `.` для вызова метода на структуре.

### Оператор `scope_return` (`^`)

Для того чтобы показать, что величина должна быть возвращена из блока `{}` в Rust используется отсутствие `;`. Это приводит к часто ложным срабатываниям , если мы не хотели бы возвращать ничего из блока, например в цикле `for`:

```rust
fn print_and_return(i: i32) -> i32 { .. }

fn main() {
    //   ^ compilation error - main has to return void
    for i in 0..10 {
        print_and_return(i)
    }
//  ^ return type of for loop is i32
//   so is the return type of main function
}
```

Для того чтобы обойти эту проблему, особенно при отсутствии `;` как элемента синтаксиса существует оператор `^` - `scope_return`.

Только при наличии этого оператора мы можем вернуть что-то из блока:

```rust
fn main() {
    let i = {
        println!("i initialized")
        ^ 10
    }
}
```

Не компилируется TODO ?????????

```rust
fn main() {
    let i = {
        println!("i initialized")
        10
    }
}
```

### Удобные операторы `&`,`!`,`*` и т.д.

Операторы `&`,`!`,`*` и т.д. всегда ставятся перед началом цепочки вызова полей, методов. Например:

```rust
let my_ref: &i32 = &user.id.hash();
let my_not_bool: bool = !user.inner.is_some();
```

### Функции

Короткая запись функций через `=`.

```rust
fn add(a: i32, b: i32) -> i32 = a + b;
```

Очень полезна когда мы реализуем методы интерфейса в одну строчку, например делегируя их исполнение внутренней структуре.

```rust
struct MyVec(Vec<i32>);

impl MyVec {
    fn add(&mut self, i: i32) = self.0.push(i);
}
```
